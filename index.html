<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<title>åŸºæœ¬é›»å­å›è·¯ â€” ã‚¿ãƒƒãƒå¯¾å¿œç‰ˆ</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<style>
  :root{
    --panel:#f7f7f7;
    --accent:#0b75c9;
    --wire-on:#FFC107;
    --wire-off:#0000FF; 
    --btn-primary:#4CAF50; 
    --btn-secondary:#2196F3; 
    --btn-text:#fff;
  }
  /* ã‚¿ãƒƒãƒæ“ä½œå‘ä¸Šã®ãŸã‚ touch-action ã‚’è¨­å®š */
  body{
      font-family:Segoe UI,Meiryo,Arial,sans-serif;
      margin:0;background:#e6e6e6;height:100vh;display:flex;gap:12px;padding:12px;
      touch-action: none; /* å…¨ä½“çš„ãªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’æŠ‘åˆ¶ï¼ˆã‚¢ãƒ—ãƒªã£ã½ãã™ã‚‹ï¼‰ */
      overflow: hidden;   /* ç”»é¢å¤–ã¸ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²ã */
  }
  
  .col{background:var(--panel);border:3px solid #222;border-radius:6px;padding:12px;box-shadow:0 2px 6px rgba(0,0,0,0.15)}
  .left{width:160px;display:flex;flex-direction:column;gap:12px; overflow-y: auto;}
  .center{flex:1;display:flex;flex-direction:column;gap:12px}
  .topbar{height:86px;display:flex;align-items:center;gap:12px;padding:8px;border-bottom:2px solid #bbb; flex-shrink: 0;}
  .palette{display:flex;gap:12px}
  
  .palette .gate-p{width:72px;height:48px;border:2px solid #222;background:#fff;border-radius:6px;display:flex;align-items:center;justify-content:center;cursor:grab;box-shadow:0 2px 4px rgba(0,0,0,0.12); position:relative; touch-action: none;}
  .palette .gate-p:active{cursor:grabbing}
  .palette .gate-p svg{width:50px; height:30px; position: relative; pointer-events: none;}

  .canvas-wrap{flex:1;display:flex;flex-direction: column; position: relative; overflow: hidden;}
  .canvas{flex:1;background:#fff;border:2px dashed #bbb;border-radius:6px;position:relative;overflow:hidden; touch-action: none;}
  
  .node{position:absolute;width:84px;height:54px;background:#fff;border:2px solid #222;border-radius:6px;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 6px rgba(0,0,0,0.12);user-select:none; overflow: visible; transition: background 0.1s, border-color 0.1s; touch-action: none;}
   
  .node .label{pointer-events:none;} 
  .node svg {pointer-events: none;}

  .node.active { background: #FFEB3B !important; border-color: #FFA000 !important; }

  /* ãƒãƒ¼ãƒˆã®ã‚¿ãƒƒãƒåˆ¤å®šã‚’åºƒã’ã‚‹ãŸã‚ã«æ“¬ä¼¼è¦ç´ ã‚’ä½¿ã£ã¦ã‚‚è‰¯ã„ãŒã€ä»Šå›ã¯ã‚µã‚¤ã‚ºãã®ã¾ã¾ã§åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã§ã‚«ãƒãƒ¼ */
  .port{position:absolute;width:12px;height:12px;background:#222;border-radius:50%; touch-action: none;}
  .port.out{right:-6px;top:50%;transform:translateY(-50%)}
  .port.in.top{left:-6px;top:20%}
  .port.in.bottom{left:-6px;top:60%}
  .port.in.center{left:-6px;top:50%;transform:translateY(-50%)}
   
  .io{width:120px;padding:8px;background:#fff;border:2px solid #222;border-radius:6px}
  .io .title{font-weight:bold;margin-bottom:8px}
   
  .truth{white-space:pre; font-family: monospace; font-size: 1.4em;} 
  table{border-collapse:collapse}
  td,th{padding:6px;border:1px solid #444;text-align:center}
  
  .right{width:200px;display:flex;flex-direction:column;gap:12px; overflow-y: auto;}
  .expect{padding:8px}
  .btns{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px;} 

  .io button{
    padding: 10px 16px; font-size: 1.1em; min-width: 40px; 
    border-radius:6px;border:2px solid #222;cursor:pointer; transition: background 0.2s;
    background: var(--btn-secondary); color: var(--btn-text); border-color: var(--btn-secondary);
  }
  .io button:hover{background: #1976D2;}
  .btns button:not(#judgeBtn){padding:6px; border-radius:6px;border:2px solid #222;cursor:pointer; transition: background 0.2s; background: #FF9800; color: #333; border-color: #FF9800; font-size: 0.85em;}
  .btns button:not(#judgeBtn):hover{background: #F57C00;}
   
  .judge-controls { display: flex; gap: 8px; margin-bottom: 8px; }
  #judgeBtn{
    flex: 2; padding: 10px; font-size: 1.1em; 
    border-radius:6px;border:2px solid #222;cursor:pointer; transition: background 0.2s; background: var(--btn-primary); color: var(--btn-text); border-color: var(--btn-primary); font-weight: bold;
  }
  #judgeBtn:hover{background: #388E3C;}
  #resetBtn{
    flex: 1; padding: 10px; font-size: 1.1em;
    border-radius: 6px; border: 2px solid #222; cursor: pointer; transition: background 0.2s;
    background: #607D8B; color: var(--btn-text); border-color: #607D8B; font-weight: bold;
  }
  #resetBtn:hover{background: #455A64;}

  #saveBtn {
    width: 100%; padding: 12px; font-size: 1.1em;
    border-radius: 6px; border: 2px solid #222; cursor: pointer; transition: background 0.2s;
    background: #9C27B0; color: var(--btn-text); border-color: #9C27B0; font-weight: bold;
    display: flex; align-items: center; justify-content: center; gap: 8px;
  }
  #saveBtn:hover { background: #7B1FA2; }

  .judge{ margin-top:12px; font-size: 24px; padding: 8px 0; text-align: center; }
  .ok, .ng{ font-size: 24px; padding: 8px 0; text-align: center; font-weight:bold; }
  .ok{color:green;} .ng{color:red;}

  .small{font-size:12px;color:#444}
  .small b {font-weight: bold; color: #000;} 
  #curBits{ font-size: 1.4em; font-weight: bold; color: var(--accent); }
  svg.wires{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
  .port.highlight{ outline: 3px solid #ff0000; box-shadow: 0 0 5px rgba(255, 0, 0, 0.8); }
</style>
</head>
<body>
  <div class="col left">
    <div class="io">
      <div class="title">å…¥åŠ› (X, Y)</div>
      <div style="display:flex;gap:8px;align-items:center;justify-content:center">
        <button onclick="setBits('00')">00</button>
        <button onclick="setBits('01')">01</button>
        <button onclick="setBits('10')">10</button>
        <button onclick="setBits('11')">11</button>
      </div>
      <div style="margin-top:8px;text-align:center">ç¾åœ¨: <span id="curBits">--</span></div>
    </div>

    <div class="io">
      <div class="title">çœŸç†å€¤è¡¨ (å…¥åŠ›ã®ã¿)</div>
      <table style="width:100%">
        <tr><th>X</th><th>Y</th></tr>
        <tbody id="expectTable"></tbody>
      </table>
    </div>

    <div class="small" style="padding-top: 4px;">
      æ¥ç¶šæ–¹æ³•ï¼šå‡ºåŠ›ãƒãƒ¼ãƒˆã‚’<b>ãƒ‰ãƒ©ãƒƒã‚°</b> â†’ å…¥åŠ›ãƒãƒ¼ãƒˆã§<b>é›¢ã™</b>ã€‚<br>
      åˆ‡æ–­ï¼šå…¥åŠ›ãƒãƒ¼ãƒˆã‚’<b>ã‚¿ãƒƒãƒ—</b>ã€‚<br>
      ãƒ–ãƒ­ãƒƒã‚¯å‰Šé™¤ï¼šãƒ–ãƒ­ãƒƒã‚¯ã‚’<b>ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—</b>ã™ã‚‹ã‹ã€<b>ãƒˆãƒƒãƒ—ãƒãƒ¼ã¸ãƒ‰ãƒ©ãƒƒã‚°</b>ã€‚
    </div>
  </div>

  <div class="col center">
    <div class="topbar" id="topbar">
      <div class="palette" id="palette">
        <div class="gate-p" data-type="AND" id="paletteAND"></div>
        <div class="gate-p" data-type="OR" id="paletteOR"></div>
        <div class="gate-p" data-type="NOT" id="paletteNOT"></div>
      </div>
      <div style="margin-left:auto">
        <div class="small">ãƒ‘ãƒ¬ãƒƒãƒˆï¼šã“ã“ã«ãƒ‰ãƒ­ãƒƒãƒ—ã§ãƒãƒ¼ãƒ‰ã‚’å‰Šé™¤</div>
      </div>
    </div>

    <div class="canvas-wrap">
      <div class="canvas" id="canvas">
        <svg class="wires" id="wiresSvg"></svg>
        <div class="node" id="inputX" data-node="inputX" style="left:8px;top:33%">
          <div class="label">X</div> 
          <div class="port out" data-port="out" data-node="inputX" title="X out"></div>
        </div>
        <div class="node" id="inputY" data-node="inputY" style="left:8px;top:66%">
          <div class="label">Y</div> 
          <div class="port out" data-port="out" data-node="inputY" title="Y out"></div>
        </div>
        <div class="node" id="outputZ" data-node="outputZ" style="right:8px;top:33%">
          <div class="label">Z (SUM)</div> 
          <div class="port in center" data-port="in" data-node="outputZ" title="Z in" data-index="0"></div>
        </div>
        <div class="node" id="outputC" data-node="outputC" style="right:8px;top:66%">
          <div class="label">C (CARRY)</div> 
          <div class="port in center" data-port="in" data-node="outputC" title="C in" data-index="0"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="col right">
    <div class="expect">
      <div class="title">å‡ºé¡Œ (æœŸå¾…å‡ºåŠ›)</div>
      <div class="btns">
        <button onclick="setExpected('AND')">AND</button>
        <button onclick="setExpected('OR')">OR</button>
        <button onclick="setExpected('NAND')">NAND</button>
        <button onclick="setExpected('NOR')">NOR</button>
        <button onclick="setExpected('XOR')">XOR</button>
        <button onclick="setExpected('XNOR')">XNOR</button>
        <button onclick="setExpected('NOT_X')">XÌ„</button>
        <button onclick="setExpected('NOT_Y')">È²</button>
        <button onclick="setExpected('NOT_X_AND_Y')">XÌ„ãƒ»Y</button>
        <button onclick="setExpected('X_AND_NOT_Y')">Xãƒ»È²</button>
        <button onclick="setExpected('NOT_X_OR_Y')">XÌ„+Y</button>
        <button onclick="setExpected('X_OR_NOT_Y')">X+È²</button>
        <button onclick="setExpected('NOT_X_AND_NOT_Y')">XÌ„ãƒ»È²</button>
        <button onclick="setExpected('NOT_X_OR_NOT_Y')">XÌ„+È²</button>
        <button onclick="setExpected('HALF_SUM')">åŠåŠ ç®—å™¨(SUM)</button>
        <button onclick="setExpected('HALF_CARRY')">åŠåŠ ç®—å™¨(CARRY)</button>
      </div>
      <div style="margin-top: 12px; font-size: 1.1em;">
        <div class="small" style="font-weight: bold; color:#222;">Z/C (æœŸå¾…å€¤)</div>
        <pre class="truth" id="expectedTruthTable">--</pre>
      </div>
    </div>

    <div class="expect">
      <div class="judge-controls">
        <button onclick="judgeCircuit()" id="judgeBtn">å‡ºåŠ›åˆ¤å®š</button>
        <button onclick="resetJudge()" id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
      </div>
      <div class="judge" id="judgeResult">æœªåˆ¤å®š</div>
      <div style="margin-top: 24px; border-top: 1px solid #ccc; padding-top:16px;">
        <button onclick="saveCircuitImage()" id="saveBtn">ğŸ“· å›è·¯å›³ã‚’ä¿å­˜ (PNG)</button>
      </div>
    </div>
  </div>

<script>
// Data structures
let nodes = {}; 
let wires = []; 
let expect = 'XOR'; 
let curBits = null; 

let pendingConnection = null; 
let highlightedPort = null; 

function uid(prefix='n'){return prefix+Math.random().toString(36).slice(2,9)}

setExpected('XOR');

// ----------------- SVG Logic Gate Symbols -----------------

function getGateSvg(type, isPalette = false) {
    let w = 60; let h = 40; 
    let style = isPalette ? '' : 'style="position:absolute; left:12px; top:7px;"'; 
    let viewBox = `0 0 ${w} ${h}`;
    switch (type) {
        case 'AND':
            return `<svg viewBox="${viewBox}" width="${w}" height="${h}" ${style}>
                <path d="M0 0 L15 0 A20 20 0 0 1 15 40 L0 40 Z" fill="#fff" stroke="#222" stroke-width="2"/>
                <path d="M15 0 A20 20 0 0 1 15 40" fill="none" stroke="#222" stroke-width="2"/>
                <line x1="0" y1="10" x2="0" y2="30" stroke="none"/>
            </svg>`;
        case 'OR':
            return `<svg viewBox="${viewBox}" width="${w}" height="${h}" ${style}>
                <path d="M0 0 Q10 20 0 40 L10 40 Q45 35 60 20 Q45 5 10 0 Z" fill="#fff" stroke="#222" stroke-width="2"/>
            </svg>`;
        case 'NOT':
            return `<svg viewBox="0 0 50 40" width="50" height="40" ${isPalette ? '' : 'style="position:absolute; left:17px; top:7px;"'}>
                <path d="M0 0 L40 20 L0 40 Z" fill="#fff" stroke="#222" stroke-width="2"/>
                <circle cx="44" cy="20" r="4" fill="#fff" stroke="#222" stroke-width="2"/>
            </svg>`;
        default:
            return `<div class="label">${type}</div>`;
    }
}

// ----------------- Touch/Mouse Helper -----------------
// ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰åº§æ¨™(X, Y)ã‚’å–å¾—ã™ã‚‹å…±é€šé–¢æ•°
function getXY(e) {
  if(e.changedTouches && e.changedTouches.length > 0) {
    return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
  }
  return { x: e.clientX, y: e.clientY };
}

// ----------------- Palette Logic (Touch & Mouse) -----------------
const palette = document.getElementById('palette');
const canvas = document.getElementById('canvas');

// ãƒ‘ãƒ¬ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã«ã‚¤ãƒ™ãƒ³ãƒˆç™»éŒ²
palette.querySelectorAll('.gate-p').forEach(p => {
  // ãƒã‚¦ã‚¹ç”¨ (HTML5 DnD) - PCã§ã®äº’æ›æ€§ç¶­æŒ
  p.draggable = true;
  p.addEventListener('dragstart', e => {
    e.dataTransfer.setData('text/gate', p.dataset.type);
  });

  // ã‚¿ãƒƒãƒç”¨ (Custom Logic) - iPad/Chromebookå¯¾å¿œ
  p.addEventListener('touchstart', e => {
    e.preventDefault(); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢
    const type = p.dataset.type;
    const rect = canvas.getBoundingClientRect();
    const pos = getXY(e);
    
    // ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã®åˆæœŸä½ç½®ï¼ˆæŒ‡ã®ä¸‹ã«æ¥ã‚‹ã‚ˆã†ã«è¨ˆç®—ï¼‰
    // è£œæ­£å€¤: ãƒ‘ãƒ¬ãƒƒãƒˆã®ç›¸å¯¾ä½ç½®ãªã©è€ƒæ…®ã›ãšã€å˜ç´”ã«ã‚­ãƒ£ãƒ³ãƒã‚¹å·¦ä¸ŠåŸºæº–ã§é…ç½®
    const x = pos.x - rect.left - 42; 
    const y = pos.y - rect.top - 27;

    const newNode = createNode(type, x, y);
    
    // ç”Ÿæˆã—ãŸç›´å¾Œã«ãƒ‰ãƒ©ãƒƒã‚°ã‚’é–‹å§‹ã•ã›ã‚‹
    startNodeDragDirectly(newNode, e);
  }, {passive: false});
});

// Canvas Drop (Mouse)
canvas.addEventListener('dragover', e=>e.preventDefault());
canvas.addEventListener('drop', e=>{
  e.preventDefault();
  const type = e.dataTransfer.getData('text/gate');
  if(!type) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left - 42; 
  const y = e.clientY - rect.top - 27;
  createNode(type, x, y);
});

// Node Deletion Area (Topbar)
const topbar = document.getElementById('topbar');
topbar.addEventListener('dragover', e=>e.preventDefault());
topbar.addEventListener('drop', e=>{
  e.preventDefault();
  const id = e.dataTransfer.getData('text/nodeId');
  if(id) removeNode(id);
});

// ----------------- Node Creation & Logic -----------------

function createNode(type,x=100,y=80){
  const id = uid('node');
  const el = document.createElement('div');
  el.className = 'node';
  el.dataset.node = id;
  el.style.left = x+'px'; el.style.top = y+'px';
  el.innerHTML = getGateSvg(type); 
  canvas.appendChild(el);

  // Output port
  const portOut = document.createElement('div');
  portOut.className='port out'; portOut.dataset.port='out'; portOut.dataset.node=id;
  // ãƒã‚¦ã‚¹ãƒ»ã‚¿ãƒƒãƒä¸¡æ–¹ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’ç™»éŒ²
  portOut.addEventListener('mousedown', startWireDrag); 
  portOut.addEventListener('touchstart', startWireDrag, {passive: false});
  el.appendChild(portOut);

  // Input ports
  if(type === 'NOT'){
    const portIn1 = createInPort(id, 'center', '0');
    el.appendChild(portIn1);
    nodes[id] = {id,type,x,y,inputs:[null],dom:el};
  } else {
    const portIn1 = createInPort(id, 'top', '0');
    el.appendChild(portIn1);
    const portIn2 = createInPort(id, 'bottom', '1');
    el.appendChild(portIn2);
    nodes[id] = {id,type,x,y,inputs:[null,null],dom:el};
  }

  makeNodeDraggable(el);
  renderWires();
  updateCircuitVisuals(); 
  return el; // ç”Ÿæˆã—ãŸDOMã‚’è¿”ã™
}

function createInPort(nodeId, posClass, index){
  const p = document.createElement('div');
  p.className = `port in ${posClass}`;
  p.dataset.port = 'in';
  p.dataset.node = nodeId;
  p.dataset.index = index;
  // Click/Tap to disconnect
  p.addEventListener('click', disconnectWire);
  // Touch specific for disconnect (tap behavior)
  p.addEventListener('touchend', disconnectWire);
  return p;
}

function removeNode(id){
  if(!nodes[id]) return; 
  wires = wires.filter(w=>{
    if(w.from.node===id || w.to.node===id){
      if(w.pathElem) w.pathElem.remove();
      return false;
    }
    return true;
  });
  const nodeEl = document.querySelector(`[data-node='${id}']`);
  if(nodeEl) nodeEl.remove();
  delete nodes[id];
  renderWires();
  updateCircuitVisuals(); 
}

// ----------------- Node Dragging (Unified Mouse & Touch) -----------------

function makeNodeDraggable(el){
  el.draggable = true; // For Mouse Drag to trash
  
  // Double Click / Double Tap to delete
  let lastTap = 0;
  el.addEventListener('touchend', e=>{
      const currentTime = new Date().getTime();
      const tapLength = currentTime - lastTap;
      if (tapLength < 500 && tapLength > 0) {
          e.preventDefault();
          removeNode(el.dataset.node);
      }
      lastTap = currentTime;
  });
  el.addEventListener('dblclick', e => {
      e.stopPropagation(); 
      removeNode(el.dataset.node);
  });
   
  // HTML5 Drag Start (Mouse only, for Trash bin)
  el.addEventListener('dragstart', e=>{
    if(pendingConnection) {e.preventDefault(); return;}
    e.dataTransfer.setData('text/nodeId', el.dataset.node);
    const img = new Image(); 
    img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; 
    e.dataTransfer.setDragImage(img, 0, 0);
  });
   
  // Unified Move Logic (Mouse Down & Touch Start)
  const startMove = (e) => {
    if(e.target.classList.contains('port')) return; 
    // HTML5 DragãŒç™ºç«ã—ãªã„ã‚ˆã†ã«æ¨™æº–å‹•ä½œã‚’é˜²ãï¼ˆã‚¿ãƒƒãƒã®å ´åˆï¼‰
    if(e.type === 'touchstart') e.preventDefault();

    startNodeDragDirectly(el, e);
  };

  el.addEventListener('mousedown', startMove);
  el.addEventListener('touchstart', startMove, {passive: false});
}

// ãƒãƒ¼ãƒ‰ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç†ã®å®Ÿä½“
function startNodeDragDirectly(el, e) {
    const id = el.dataset.node;
    const pos = getXY(e);
    const startX = pos.x; 
    const startY = pos.y;
    const oLeft = parseFloat(el.style.left); 
    const oTop = parseFloat(el.style.top);
    
    // ãƒˆãƒƒãƒ—ãƒãƒ¼(ã‚´ãƒŸç®±)ã‚¨ãƒªã‚¢ã®åˆ¤å®šç”¨
    const topbarRect = topbar.getBoundingClientRect();

    function onmove(ev){
      if(ev.type === 'touchmove') ev.preventDefault(); // Stop scroll
      const curr = getXY(ev);
      const nx = oLeft + (curr.x - startX);
      const ny = oTop + (curr.y - startY);
      el.style.left = nx + 'px'; el.style.top = ny+'px';
      
      if(nodes[id]){ nodes[id].x = nx; nodes[id].y = ny; }
      renderWires();

      // Simple Trash Highlight visual
      if(curr.y < topbarRect.bottom) {
         topbar.style.backgroundColor = '#ffe0e0';
      } else {
         topbar.style.backgroundColor = '';
      }
    }
    
    function onup(ev){
        document.removeEventListener('mousemove',onmove);
        document.removeEventListener('mouseup',onup);
        document.removeEventListener('touchmove',onmove);
        document.removeEventListener('touchend',onup);
        topbar.style.backgroundColor = '';

        // Drop in Trash?
        const endPos = getXY(ev);
        if(endPos.y < topbarRect.bottom) {
            removeNode(id);
        }
    }
    
    document.addEventListener('mousemove',onmove);
    document.addEventListener('mouseup',onup);
    document.addEventListener('touchmove',onmove, {passive: false});
    document.addEventListener('touchend',onup);
}


// ----------------- Wire Creation (Unified Mouse & Touch) -----------------

function startWireDrag(e){
  // ãƒãƒ¼ãƒˆã‹ã‚‰é–‹å§‹
  e.stopPropagation(); 
  if(e.type === 'mousedown' && e.button !== 0) return; 
  if(e.type === 'touchstart') e.preventDefault(); // Stop scroll

  const outputPort = e.target;
  const fromNodeId = outputPort.dataset.node;

  const svg = document.getElementById('wiresSvg');
  const tempPath = document.createElementNS('http://www.w3.org/2000/svg','path');
  tempPath.setAttribute('stroke', 'var(--wire-off)');
  tempPath.setAttribute('stroke-width', '3px');
  tempPath.setAttribute('fill', 'none');
  svg.appendChild(tempPath);

  const canvasRect = canvas.getBoundingClientRect();
  const startCoord = getCenter(outputPort, canvasRect);

  pendingConnection = {
    from: {node: fromNodeId},
    startCoord: startCoord,
    tempPath: tempPath
  };
   
  document.addEventListener('mousemove', dragWireMove);
  document.addEventListener('mouseup', dropWire);
  document.addEventListener('touchmove', dragWireMove, {passive: false});
  document.addEventListener('touchend', dropWire);
  
  outputPort.style.outline='3px solid rgba(0,150,255,0.6)'; 
}

function dragWireMove(e){
  if(!pendingConnection) return;
  if(e.type === 'touchmove') e.preventDefault(); 

  const canvasRect = canvas.getBoundingClientRect();
  const pos = getXY(e);
  const currentX = pos.x - canvasRect.left;
  const currentY = pos.y - canvasRect.top;
  
  const d = `M ${pendingConnection.startCoord.x} ${pendingConnection.startCoord.y} L ${currentX} ${currentY}`;
  pendingConnection.tempPath.setAttribute('d', d);

  // Hit testing logic
  const inputPorts = document.querySelectorAll('.port.in');
  let closestPort = null;
  let minDistance = 40; // æŒ‡ã ã¨éš ã‚Œã‚‹ã®ã§åˆ¤å®šç¯„å›²ã‚’åºƒã’ã‚‹ (25->40)

  if(highlightedPort) {
    highlightedPort.classList.remove('highlight');
    highlightedPort = null;
  }

  inputPorts.forEach(port => {
    const portCenter = getCenter(port, canvasRect);
    const dx = portCenter.x - currentX;
    const dy = portCenter.y - currentY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance < minDistance) {
      minDistance = distance;
      closestPort = port;
    }
  });

  if (closestPort) {
    closestPort.classList.add('highlight'); 
    highlightedPort = closestPort;
  }
}

function dropWire(e){
  document.removeEventListener('mousemove', dragWireMove);
  document.removeEventListener('mouseup', dropWire);
  document.removeEventListener('touchmove', dragWireMove);
  document.removeEventListener('touchend', dropWire);

  document.querySelectorAll('.port.out').forEach(p=>p.style.outline='');
   
  if(!pendingConnection) return;
  pendingConnection.tempPath.remove();
   
  // Touchã®å ´åˆã€highlightedPortãŒç›´å‰ã®moveã§ã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã‚‹ã¯ãš
  if (highlightedPort) {
    const toNodeId = highlightedPort.dataset.node;
    const toIndex = parseInt(highlightedPort.dataset.index || '0');
    
    // Disconnect existing wire to the *same* input port
    wires = wires.filter(w=>{
      const same = (w.to.node===toNodeId && w.to.index===toIndex);
      if(same){ if(w.pathElem) w.pathElem.remove(); }
      return !same;
    });

    const wire = {from: pendingConnection.from, to: {node: toNodeId, index: toIndex}};
    wires.push(wire); 
    
    highlightedPort.classList.remove('highlight');
    highlightedPort = null;
  }
   
  pendingConnection = null;
  renderWires(); 
  updateCircuitVisuals(); 
}

function disconnectWire(e){
  e.stopPropagation();
  e.preventDefault(); // Prevent double fire (touch+click)
  
  const portEl = e.target;
  const toNodeId = portEl.dataset.node;
  const toIndex = parseInt(portEl.dataset.index || '0');

  let removed = false;
  wires = wires.filter(w => {
    const isTarget = (w.to.node === toNodeId && w.to.index === toIndex);
    if (isTarget) {
      if (w.pathElem) w.pathElem.remove();
      removed = true;
      return false;
    }
    return true;
  });

  if (removed) {
    renderWires(); 
    updateCircuitVisuals(); 
  }
}

// ----------------- Rendering & Updates -----------------

function renderWires(){
  const svg = document.getElementById('wiresSvg');
  Array.from(svg.children).filter(el => el !== pendingConnection?.tempPath).forEach(el => el.remove());
   
  wires.forEach(w=>{
    const fromEl = document.querySelector(`[data-node='${w.from.node}']`);
    const toEl = document.querySelector(`[data-node='${w.to.node}']`);
    if(!fromEl || !toEl) return;
    
    const fromPort = fromEl.querySelector('.port.out');
    const toPort = toEl.querySelector(`.port.in[data-index='${w.to.index}']`) || toEl.querySelector('.port.in.center'); 
    if (!fromPort || !toPort) return;

    const r = canvas.getBoundingClientRect();
    const p1 = getCenter(fromPort, r); const p2 = getCenter(toPort, r);

    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    const d = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
    path.setAttribute('d',d);
    path.setAttribute('stroke', 'var(--wire-off)');
    path.setAttribute('stroke-width', '3px'); 
    path.setAttribute('fill','none');
    svg.appendChild(path);
    w.pathElem = path; 
  });
}
function getCenter(el, baseRect){
  const r = el.getBoundingClientRect();
  return {x: r.left - baseRect.left + r.width/2, y: r.top - baseRect.top + r.height/2};
}

function getCircuitState(bits){
    const val = {}; 
    val['inputX'] = parseInt(bits[0]); 
    val['inputY'] = parseInt(bits[1]);
    
    const outputMap = {};
    const cache = {};

    function compute(nodeId){
      if(cache.hasOwnProperty(nodeId)) return cache[nodeId];
      if(nodeId==='inputX' || nodeId==='inputY') return cache[nodeId]=val[nodeId];
      
      const node = nodes[nodeId];
      if(!node){return 0}
      
      const inVals = [0,0];
      const maxInputs = node.type==='NOT'? 1: 2;
      
      wires.forEach(w=>{
        if(w.to.node===nodeId && w.to.index < maxInputs){
          inVals[w.to.index] = compute(w.from.node);
        }
      });
      
      let out=0; 
      switch(node.type){
        case 'AND': out = (inVals[0] & inVals[1]); break;
        case 'OR': out = (inVals[0] | inVals[1]); break;
        case 'NOT': out = (inVals[0]?0:1); break;
        default: out=0;
      }
      cache[nodeId]=out;
      return out;
    }
    
    Object.keys(nodes).forEach(id => { outputMap[id] = compute(id); });
    let z = 0; wires.forEach(w=>{ if(w.to.node==='outputZ'){ z = compute(w.from.node); } });
    outputMap['outputZ'] = z;
    let c = 0; wires.forEach(w=>{ if(w.to.node==='outputC'){ c = compute(w.from.node); } });
    outputMap['outputC'] = c;
    outputMap['inputX'] = val['inputX'];
    outputMap['inputY'] = val['inputY'];
    return outputMap;
}

function updateCircuitVisuals(){
    if(!curBits) return; 
    const state = getCircuitState(curBits);
    const allNodes = [...Object.keys(nodes), 'inputX', 'inputY', 'outputZ', 'outputC'];
    allNodes.forEach(id => {
        const nodeEl = document.querySelector(`[data-node='${id}']`);
        if (!nodeEl) return;
        const outputValue = state[id] || 0; 
        nodeEl.classList.toggle('active', outputValue === 1);
    });
    wires.forEach(w => {
        const path = w.pathElem;
        if (path) {
            const fromNodeId = w.from.node;
            const wireIsOn = state[fromNodeId] === 1;
            path.setAttribute('stroke', wireIsOn ? 'var(--wire-on)' : 'var(--wire-off)');
        }
    });
}

function evaluateFor(bits){
  const state = getCircuitState(bits);
  if (expect === 'HALF_CARRY') return state['outputC'] || 0;
  else return state['outputZ'] || 0;
}
function setExpected(type){ expect = type; updateExpectTable(); updateExpectedTruthTable(); }
function updateExpectTable(){
  const tbody = document.getElementById('expectTable'); tbody.innerHTML='';
  ['00','01','10','11'].forEach(b=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${b[0]}</td><td>${b[1]}</td>`;
    tbody.appendChild(tr);
  });
}
function updateExpectedTruthTable(){
  const truthEl = document.getElementById('expectedTruthTable');
  const outputLabel = (expect === 'HALF_CARRY') ? 'C' : 'Z';
  let table = `X | Y | ${outputLabel}\n--|---|---\n`;
  ['00','01','10','11'].forEach(b=>{
    table += `${b[0]} | ${b[1]} | ${expectedFor(b)}\n`;
  });
  truthEl.textContent = table;
}
function expectedFor(bits){ 
  const x=parseInt(bits[0]), y=parseInt(bits[1]);
  const notX = x ? 0 : 1;
  const notY = y ? 0 : 1;
  switch(expect){
    case 'AND': return (x & y); 
    case 'OR': return (x | y); 
    case 'NAND': return ( (x & y) ? 0 : 1 );
    case 'NOR': return ( (x|y) ? 0 : 1 );
    case 'XOR': return ( x ^ y );
    case 'XNOR': return ( (x ^ y) ? 0 : 1 );
    case 'NOT_X': return notX; 
    case 'NOT_Y': return notY; 
    case 'NOT_X_AND_Y': return (notX & y);
    case 'X_AND_NOT_Y': return (x & notY);
    case 'NOT_X_OR_Y': return (notX | y);
    case 'X_OR_NOT_Y': return (x | notY);
    case 'NOT_X_AND_NOT_Y': return (notX & notY);
    case 'NOT_X_OR_NOT_Y': return (notX | notY);
    case 'HALF_SUM': return ( x ^ y );
    case 'HALF_CARRY': return ( x & y );
  }
  return 0;
}
function setBits(b){ curBits = b; document.getElementById('curBits').textContent=b; updateCircuitVisuals(); }
function judgeCircuit(){
  const combos = ['00','01','10','11'];
  const expected = combos.map(c=>expectedFor(c));
  const targetNodeId = (expect === 'HALF_CARRY') ? 'outputC' : 'outputZ';
  const targetOutputBlockName = (expect === 'HALF_CARRY') ? 'C (CARRY)' : 'Z (SUM)';
  const isConnected = wires.some(w => w.to.node === targetNodeId);
  const judgeEl = document.getElementById('judgeResult');
  if (!isConnected) {
      judgeEl.textContent = `Ã— æœŸå¾…å‡ºåŠ›ãƒ–ãƒ­ãƒƒã‚¯ (${targetOutputBlockName}) ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã›ã‚“`;
      judgeEl.className = 'ng';
      return;
  }
  const outputs = combos.map(c=>evaluateFor(c)); 
  const ok = expected.every((v,i)=>v==outputs[i]);
  judgeEl.textContent = ok? 'ã€‡ã€€æ­£è§£' : 'Ã—ã€€ä¸æ­£è§£';
  judgeEl.className = ok? 'ok':'ng';
  updateCircuitVisuals(); 
}
function resetJudge() {
    const judgeEl = document.getElementById('judgeResult');
    judgeEl.textContent = 'æœªåˆ¤å®š';
    judgeEl.className = 'judge';
}
function saveCircuitImage() {
    const canvasElement = document.getElementById('canvas');
    if(!canvasElement) return;
    html2canvas(canvasElement, { backgroundColor: '#ffffff', scale: 2 }).then(canvas => {
        const link = document.createElement('a');
        link.download = 'logic_circuit.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    }).catch(err => { alert("ç”»åƒã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); });
}

// ----------------- Initialize -----------------
function initializePaletteSymbols() {
    document.getElementById('paletteAND').innerHTML = getGateSvg('AND', true);
    document.getElementById('paletteOR').innerHTML = getGateSvg('OR', true);
    document.getElementById('paletteNOT').innerHTML = getGateSvg('NOT', true);
}
initializePaletteSymbols();

// å›ºå®šãƒãƒ¼ãƒ‰ã¸ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚‚ã‚¿ãƒƒãƒå¯¾å¿œã•ã›ã‚‹
const fixedPorts = [
    document.querySelector('#inputX .port.out'),
    document.querySelector('#inputY .port.out')
];
fixedPorts.forEach(p => {
    p.addEventListener('mousedown', startWireDrag);
    p.addEventListener('touchstart', startWireDrag, {passive: false});
});

const fixedInPorts = [
    document.querySelector('#outputZ .port.in'),
    document.querySelector('#outputC .port.in')
];
fixedInPorts.forEach(p => {
    p.addEventListener('click', disconnectWire);
    p.addEventListener('touchend', disconnectWire);
});

// ãƒ‘ãƒ¬ãƒƒãƒˆã®ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆPCç”¨ï¼‰ã¯ç¶­æŒ
palette.querySelectorAll('.gate-p').forEach(p=>{
  p.addEventListener('dblclick', e=>{ createNode(p.dataset.type, 200,100); });
});
</script>
</body>
</html>